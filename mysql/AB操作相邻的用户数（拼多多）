表格字段为user_id,oprerate_type,create_time，
让统计有A操作然后又有B操作这种用户模式的用户数目，要求A操作和B操作要相邻

user_id  oprerate_type  create_time
1	A	2019-09-01 12:20:21
1	A	2019-09-02 00:00:00
1	B	2019-09-03 00:00:00
2	B	2019-09-02 13:00:00
2	A	2019-09-01 15:00:00
2	B	2019-08-31 00:00:00
3	A	2019-09-05 00:00:00
3	B	2019-08-07 00:00:00
3	B	2019-09-06 00:00:00
4	A	2019-09-03 00:00:00
4	B	2019-09-08 01:00:00

第一步：使用窗口函数 lead(create_time) 求出create_time紧邻的下一个操作时间
1	A	2019-09-01 12:20:21	 2019-09-02 00:00:00	A
1	A	2019-09-02 00:00:00	 2019-09-03 00:00:00	B
1	B	2019-09-03 00:00:00		
2	B	2019-08-31 00:00:00	 2019-09-01 15:00:00	A
2	A	2019-09-01 15:00:00	 2019-09-02 13:00:00	B
2	B	2019-09-02 13:00:00		
3	B	2019-08-07 00:00:00	 2019-09-05 00:00:00	A
3	A	2019-09-05 00:00:00	 2019-09-06 00:00:00	B
3	B	2019-09-06 00:00:00		
4	A	2019-09-03 00:00:00	 2019-09-08 01:00:00	B
4	B	2019-09-08 01:00:00		

第二步：求出符合条件的记录：oprerate_type = 'A' and lead_oper = 'B'
1	A	2019-09-01 12:20:21	 2019-09-02 00:00:00	A	0
1	A	2019-09-02 00:00:00	 2019-09-03 00:00:00	B	1
1	B	2019-09-03 00:00:00			                    0
2	B	2019-08-31 00:00:00	 2019-09-01 15:00:00	A	0
2	A	2019-09-01 15:00:00	 2019-09-02 13:00:00	B	1
2	B	2019-09-02 13:00:00			                    0
3	B	2019-08-07 00:00:00	 2019-09-05 00:00:00	A	0
3	A	2019-09-05 00:00:00	 2019-09-06 00:00:00	B	1
3	B	2019-09-06 00:00:00			                    0
4	A	2019-09-03 00:00:00	 2019-09-08 01:00:00	B	1
4	B	2019-09-08 01:00:00			                    0

第三步：使用cte表达式计算出符合条件记录的 distinct 后的用户数量
4


with c as (
select b.*, case when oprerate_type = 'A' and lead_oper = 'B' then 1 else 0 end as istrue
from (
select *, lead(create_time,1) over(partition by user_id order by create_time) as lead_time,
lead(oprerate_type) over(partition by user_id order by create_time) as lead_oper
from ope) as b )
select count(DISTINCT user_id) as final_count from c where istrue = 1;
