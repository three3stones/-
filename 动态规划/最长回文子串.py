# coding=UTF-8
# 5. 最长回文子串
# 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。

"""
记号说明：
s[l, r] 表示原始字符串的一个子串，l、r 分别是区间的左右边界的索引值，
使用左闭、右闭区间表示左右边界可以取到。举个例子，当 s = 'babad' 时，s[0, 1] = 'ba' ，s[2, 4] = 'bad'。

dp[l][r] 表示子串 s[l, r]（包括区间左右端点）是否构成回文串，是一个二维布尔型数组。
即如果子串 s[l, r] 是回文串，那么 dp[l][r] = true。

状态转移方程:
1、当子串只包含 1 个字符，它一定是回文子串；
2、当子串包含 2 个以上字符的时候：如果 s[l, r] 是一个回文串，例如 “abccba”，那么这个回文串两边各往里面收缩一个字符的子串 
s[l + 1, r - 1] 也一定是回文串，即：如果 dp[l][r] == true 成立，一定有 dp[l + 1][r - 1] = true 成立。

这里还需要再多考虑一点点：“原字符串去掉左右边界”的子串的边界情况
1、当原字符串的元素个数为 3 个的时候，如果左右边界相等，那么去掉它们以后，只剩下 1 个字符，它一定是回文串，故原字符串也一定是回文串；
2、当原字符串的元素个数为 2 个的时候，如果左右边界相等，那么去掉它们以后，只剩下 0 个字符，显然原字符串也一定是回文串。

综上所述:
如果一个字符串的左右边界相等，以下二者之一成立即可：
1、去掉左右边界以后的字符串不构成区间，即“ s[l + 1, r - 1] 至少包含两个元素”的反面，即 l - r >= -2，或者 r - l <= 2；
2、去掉左右边界以后的字符串是回文串，具体说，它的回文性决定了原字符串的回文性。

"""
class Solution:
    def longestPalindrome(self,s):
        size = len(s)
        if size <= 1:
            return s
        # 状态矩阵dp
        dp = [[False for _ in range(size)] for _ in range(size)]
        res = s[0]      # 最终输出结果
        longest = 1     # 结果长度

        # 因为只有 1 个字符的情况在最开始做了判断
        # 左边界一定要比右边界小，因此右边界从 1 开始
        for r in range(1,size):
            for l in range(r):
                # 状态转移方程：如果头尾字符相等并且中间也是回文
                # 在头尾字符相等的前提下，如果 r 和 l 中间只有一个元素或者没有元素，直接返回 True 即可
                # 否则要继续看收缩以后的区间的回文性
                # 重点理解 or 的短路性质在这里的作用
                if s[r] == s[l] and (r-l <= 2 or dp[l+1][r-1]):
                    dp[l][r] = True
                    if longest < r-l+1:
                        longest = r-l+1
                        res = s[l:r+1]
        
        return res

if __name__ == "__main__":
    a = Solution()
    b = a.longestPalindrome("abcdedcb")
    print(b)    # bcdedcb