# 找出出现一次的三个数的其中一个
# 题目描述：
# 一个数组里，除了三个数是唯一出现的，其余的数都出现偶数次，找出这三个数中的任意一个。
# 比如数组序列为 [1,2,4,5,6,4,2] ，只有 1, 5, 6 三个数字是唯一出现的，其他数字均出现了偶数次，只需要输出数字1, 5, 6中的任意一个就行。

"""
分析可知：
（1）数组中元素个数一定是奇数个
（2）由于只有三个数字出现过一次，显然这三个数字不相同，因此，这三个数对应的二进制数也不可能完全相同

由此可知，必定能找到二进制数中的某 bit 来区分这三个数 (这一个bit 的取值或者为 0，或者为 1)，当通过这 bit 的值对数组进行分组的时候，
这三个数一定可以被分到两个子数组中，并且其中一个子数组中分配了两个数字，而另一个子数组分配了一个数字，而其他出现两次的数字肯定是成对出现在子数组中的。
此时我们只需要重点关注哪个子数组中分配了这三个数中的其中一个，就可以很容易地找出这个数字了。
当数组被分成两个子数组时，这一个 bit 的值为 1 的数被分到一个子数组 subArrayl, bit的值为 0 的数被分到另个子数组 subArrayO

具体实施：
以32位平台为例，一个int类型的数字占用32位空间，从右往左使用每一位对数组进行分组。
分组过程中，计算这个bit值为0的数字的异或的结果result0，出现次数count0；这个bit值为1的所有数字异或结果result1，出现次数为count1；

如果 count0是奇数 且 result1 ！= 0 ，那么说明这三个数的其中一个数被分配到了这一个bit为0的子数组。
因此，这个子数组中所有数字异或的值result0一定为出现的数字。
（如果result1=0说明这一个bit不能用来区分这三个数字，此时这三个数字都被划分到子数组subArray0中。
因此，result1！=0就可以确定这一个bit可以被用来划分这三个数字）

同理，如果count1是奇数且result0！=0，那么result1就是其中一个出现1次的数。
"""

class Solution(object):
    def isOne(self,n,i):
        return (n>>i) & 1 == 1

    def findsigle(self, arr):
        for i in range(32):         # 默认整数类型是int32
            result0 = result1 = count0 = count1 = 0
            for j in range(len(arr)):
                if self.isOne(arr[j],i):
                    count1 += 1
                    result1 ^= arr[j]
                else:
                    count0 += 1
                    result0 ^= arr[j]     
            """
            bit值为1的子数组元素个数为奇数时，且出现1次的的数字被分配到bit值为0的子数组，
            说明只有一个出现的数字被分配到bit的值为1的子数组中，异或记过就是这个出现一次的数字 
            """                 
            if count1 % 2 == 1 and result0 != 0:
                return result1
            if count0 % 2 == 1 and result1 != 0:
                return result0


a = Solution()
b = a.findsigle([6,3,4,5,9,4,3])
print(b)